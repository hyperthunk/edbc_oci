#!/usr/bin/env escript

main(Args) ->
    Options = parse_args(Args),
    case lists:keymember(help, 1, Options) of
        true ->
            help(), halt(0);
        false ->
            configure(Options)
    end.

configure(Options) ->
    io:format("~s~n", [printable(Options)]).

parse_args(Args) ->
    lists:flatten(lists:foldl(fun(Arg, Conf) -> [parse(Arg)|Conf] end, [], Args)).

parse(Arg) when is_list(Arg) ->
    first_match(Arg, args()).

first_match(Arg, []) ->
    abort("Unrecognised Option(s) ~s~n", [Arg]);
first_match(Arg, [Opt|Rest]) ->
    case match(Arg, Opt) of
        undefined ->
            first_match(Arg, Rest);
        Match ->
            Match
    end.

match(Arg, {Rx, Settings, Captures, Filter}) ->
    case re:run(Arg, Rx, [global, {capture, Captures,list}]) of
        {match, [Matches]} when is_list(Matches) ->
            case Settings of
                S when is_list(S) ->
                    lists:zip(filter(Matches, Filter), Settings);
                Merge when is_function(Merge) ->
                    Merge(filter(Matches, Filter));
                Other ->
                    abort("Invalid Settings: ~p~n", [Other])
            end;
        _Other ->
            undefined
    end.

help() ->
    io:format(
"`configure' configures this package to adapt to any supported system.

Usage: ./configure [OPTIONS]

Options:~n"),
    Indent = "    ",
    F = fun({Thing, Comments}, {Rx, _, C, _}) ->
            Text = rejoin_option(Thing, Rx, C),
            Spacer = lists:concat(lists:duplicate(28 - length(Text), " ")),
            io:format("~s~s~s~s~n", [Indent, Text, Spacer, Comments]);
           (break, _) ->
            io:format("~n");
           (Thing2, _) ->
            io:format("~s~p~n", [Indent, Thing2])
        end,
    [ F(I, A) || A <- args(), I <- (element(4, A) ++ [break]) ].

rejoin_option(Thing, Rx, C) ->
    case re:run(Rx, "\\(\?\<([^\>]+)\>[^\\)]*\\)", [global, {capture, [1], list}]) of
        {match, Matches} ->
            %% NB: our ordering comes from the matches themselves
            Indexes = erlang:tl([ string:str(C, [list_to_atom(lists:nth(1, M))]) ||
                                   M <- Matches ]),
            lists:foldl(fun(Idx, Acc) when Idx >= 0 ->
                            re:replace(Acc, "(\\([^\\)]*\\))",
                                       string:to_upper(atom_to_list(lists:nth(Idx, C))),
                                       [ungreedy, {return,list}]);
                           (_, Acc) -> Acc
                        end,
                        re:replace(Rx, "(\\([^\\)]*\\))", Thing, [ungreedy, {return,list}]),
                        Indexes);
        _ ->
            Rx
    end.

args() ->
    [
        {"--enable-(?<thing>.*)", [enabled], [thing],
            [{"64bit", "Enable 64bit mode (ignored where not applicable)"},
             {"64bit-darwin", "Default for Snow Leopard and above"},
             {"drcp", "Enable DRCP (OCI >= 11g only)"}]},
        {"--disable-(?<thing>.*)", [disabled], [thing],
            [{"64bit", "Force 32bit mode"},
             {"64bit-darwin", "Force 32bit mode on darwin-64"},
             {"drcp", "Disable Database Resident Connection Pooling "
                      "(default for OCI < 11g)"}]},
        {"--with-(?<thing>.*)=(?<where>.*)", fun erlang:list_to_tuple/1, 
        		[thing, where],
            [{"oci", "Location of the OCI install"},
             {"oracle-home", "Override ORACLE_HOME environment variable"}]},
        {"--(?<option>.*)",
            fun([X]) -> {erlang:list_to_atom(X), enabled} end, [option],
            [{"verbose", "Print lots of info out during configure process"},
             {"help", "Print out help and exit"}]}
    ].

filter(M, []) ->
    M;
filter(Match=[H|_], Filter) when is_list(Match) andalso is_integer(H) ->
    case lists:any(fun(X) -> X == Match end, allowed(Filter)) of
        false ->
            abort("Unrecognised Option(s) ~p~n", [Match]);
        true ->
            Match
    end;
filter(Matches, Filter) ->
    lists:map(fun(X) -> filter(X, Filter) end, Matches).

allowed(Filter) ->
    lists:map(fun({E,_}) -> E;(N) -> N end, Filter).

printable(Term) ->
    erl_prettypr:format(erl_parse:abstract(Term)).

abort(Msg, Args) ->
    io:format(Msg, Args), halt(1).
